import { NextRequest, NextResponse } from 'next/server';
import { getInterCredentials } from '@/lib/api-credentials';
import { getUserAuth } from '@/lib/auth-helper';
import { createClient } from '@supabase/supabase-js';
import { getInterAccessToken } from '@/lib/inter/getAccessToken';
import { realizarPagamentoPixInter } from '@/lib/inter/pixPayment';

interface PagamentoInter {
  valor: string;
  descricao: string;
  destinatario: string;
  chave: string;
  data_pagamento: string;
}

interface InterResponse {
  codigoSolicitacao: string;
  status: string;
  message?: string;
}

// Cliente Supabase
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export async function POST(request: NextRequest) {
  try {
    const body: PagamentoInter = await request.json();
    const { valor, descricao, destinatario, chave, data_pagamento } = body;

    // Obter dados do usu√°rio autenticado
    const userAuth = await getUserAuth(request);
    if (!userAuth) {
      return NextResponse.json(
        { success: false, error: 'N√£o autorizado' },
        { status: 401 }
      );
    }

    const barId = userAuth.bar_id.toString();

    // Valida√ß√µes b√°sicas
    if (!valor || !descricao || !destinatario || !chave) {
      return NextResponse.json(
        { success: false, error: 'Campos obrigat√≥rios n√£o preenchidos' },
        { status: 400 }
      );
    }

    console.log('üß™ INICIANDO PAGAMENTO PIX INTER');
    console.log('üìã Dados recebidos:', {
      valor,
      descricao,
      destinatario,
      chave,
      barId,
    });

    // Buscar credenciais do Inter para este bar
    const credenciais = await getInterCredentials(barId);
    if (!credenciais) {
      console.log('‚ùå Credenciais n√£o encontradas para bar_id:', barId);
      return NextResponse.json(
        {
          success: false,
          error: 'Credenciais do Inter n√£o configuradas para este bar',
        },
        { status: 400 }
      );
    }

    console.log('‚úÖ Credenciais encontradas:', {
      client_id: credenciais.client_id.substring(0, 8) + '...',
      conta_corrente: credenciais.conta_corrente,
    });

    console.log('‚úÖ Credenciais encontradas:', {
      client_id: credenciais.client_id.substring(0, 8) + '...',
      conta_corrente: credenciais.conta_corrente,
    });

    // Obter access token com mTLS usando fun√ß√£o da lib
    const token = await getInterAccessToken(
      credenciais.client_id,
      credenciais.client_secret,
      'pagamento-pix.write'
    );
    if (!token) {
      console.log('‚ùå Falha ao obter token de acesso');
      return NextResponse.json(
        { success: false, error: 'Erro ao obter token de acesso' },
        { status: 500 }
      );
    }

    console.log('‚úÖ Token obtido com sucesso:', token.substring(0, 20) + '...');
    console.log('‚úÖ Token completo:', token);

    // Identificar tipo de chave PIX
    const tipoChave = identificarTipoChave(chave);
    if (!tipoChave) {
      console.log('‚ùå Tipo de chave PIX n√£o identificado:', chave);
      return NextResponse.json(
        { success: false, error: 'Tipo de chave PIX n√£o identificado' },
        { status: 400 }
      );
    }

    console.log('‚úÖ Tipo de chave identificado:', tipoChave);

    // REALIZAR PAGAMENTO REAL
    console.log('üí∏ REALIZANDO PAGAMENTO REAL NO INTER');
    console.log('üì§ Dados sendo enviados para o Inter:');
    console.log('   - Valor:', valor);
    console.log('   - Descri√ß√£o:', descricao);
    console.log('   - Destinat√°rio:', destinatario);
    console.log('   - Chave:', tipoChave.chave);
    console.log('   - Conta Corrente:', credenciais.conta_corrente);
    console.log('   - Token:', token.substring(0, 20) + '...');

    // Realizar pagamento PIX real usando nova fun√ß√£o
    const resultadoPagamento = await realizarPagamentoPixInter({
      token,
      contaCorrente: credenciais.conta_corrente, // Enviar conta completa
      valor: parseFloat(valor),
      descricao,
      chave: tipoChave.chave,
    });

    if (!resultadoPagamento.success) {
      console.log('‚ùå Erro no pagamento:', resultadoPagamento.error);
      return NextResponse.json(
        { success: false, error: resultadoPagamento.error },
        { status: 500 }
      );
    }

    // Verificar se o pagamento foi aprovado
    const isAprovado = resultadoPagamento.data?.tipoRetorno === 'APROVACAO';
    const status = isAprovado ? 'APROVADO' : 'ENVIADO_PARA_APROVACAO';
    const message = isAprovado
      ? 'Pagamento PIX aprovado com sucesso'
      : 'Pagamento PIX enviado para aprova√ß√£o';

    console.log(
      `‚úÖ Pagamento PIX ${isAprovado ? 'aprovado' : 'enviado para aprova√ß√£o'}!`
    );

    // Salvar pagamento na tabela pix_enviados
    const { data: pixData, error: pixError } = await supabase
      .from('pix_enviados')
      .insert({
        txid:
          resultadoPagamento.data?.codigoSolicitacao || `inter_${Date.now()}`,
        valor: parseFloat(valor),
        beneficiario: {
          nome: destinatario,
          chave: tipoChave.chave,
          tipo: tipoChave.tipo,
        },
        data_envio: new Date().toISOString(),
        status: isAprovado ? 'APROVADO' : 'ENVIADO',
        bar_id: parseInt(barId),
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      })
      .select();

    if (pixError) {
      console.error('‚ùå Erro ao salvar PIX:', pixError);
    } else {
      console.log('‚úÖ PIX salvo na tabela:', pixData);
    }

    // Enviar notifica√ß√£o para Discord
    try {
      await enviarNotificacaoDiscord({
        valor: parseFloat(valor),
        descricao: descricao || 'Pagamento PIX',
        destinatario: destinatario,
        chave: tipoChave.chave,
        codigoSolicitacao:
          resultadoPagamento.data?.codigoSolicitacao || `inter_${Date.now()}`,
        status: status,
        barId: barId,
      });
      console.log('‚úÖ Notifica√ß√£o Discord enviada com sucesso');
    } catch (discordError) {
      console.log('‚ö†Ô∏è Erro ao enviar notifica√ß√£o Discord:', discordError);
      // N√£o falhar o pagamento se o Discord der erro
    }

    return NextResponse.json({
      success: true,
      data: resultadoPagamento.data,
      message: message,
      status: status,
      logs: [
        '‚úÖ Credenciais carregadas da tabela api_credentials',
        '‚úÖ Token obtido via mTLS com certificados PEM',
        '‚úÖ Tipo de chave PIX identificado',
        '‚úÖ Valida√ß√µes de dados passaram',
        `‚úÖ Pagamento PIX ${isAprovado ? 'aprovado' : 'enviado para aprova√ß√£o'} no Inter`,
      ],
    });
  } catch (error) {
    console.error('‚ùå Erro ao processar pagamento Inter:', error);
    return NextResponse.json(
      { success: false, error: 'Erro interno do servidor' },
      { status: 500 }
    );
  }
}

// Fun√ß√£o para enviar notifica√ß√£o para Discord
async function enviarNotificacaoDiscord(params: {
  valor: number;
  descricao: string;
  destinatario: string;
  chave: string;
  codigoSolicitacao: string;
  status: string;
  barId: string;
}) {
  try {
    const {
      valor,
      descricao,
      destinatario,
      chave,
      codigoSolicitacao,
      status,
      barId,
    } = params;

    console.log('üîç Buscando webhook Discord para bar_id:', barId);

    // Buscar webhook do Discord da tabela api_credentials
    const { data: credenciaisDiscord, error } = await supabase
      .from('api_credentials')
      .select('configuracoes')
      .eq('bar_id', barId)
      .eq('sistema', 'inter')
      .single();

    console.log('üìã Resultado da busca webhook:', {
      error: error?.message,
      configuracoes: credenciaisDiscord?.configuracoes,
    });

    if (error || !credenciaisDiscord?.configuracoes?.webhook_url) {
      console.log('‚ö†Ô∏è Webhook do Discord n√£o encontrado nas configura√ß√µes');
      console.log('‚ùå Erro:', error?.message);
      console.log('üìã Configura√ß√µes:', credenciaisDiscord?.configuracoes);
      return false;
    }

    const webhookUrl = credenciaisDiscord.configuracoes.webhook_url;
    console.log('‚úÖ Webhook encontrado:', webhookUrl);

    const embed = {
      title: 'üìã Novo Pagamento PIX Agendado',
      color: 0x0099ff, // Azul para agendamento
      fields: [
        {
          name: 'Valor',
          value: `R$ ${valor.toFixed(2)}`,
          inline: true,
        },
        {
          name: 'Destinat√°rio',
          value: destinatario,
          inline: true,
        },
        {
          name: 'Chave PIX',
          value: chave,
          inline: true,
        },
        {
          name: 'Descri√ß√£o',
          value: descricao,
          inline: false,
        },
        {
          name: 'C√≥digo de Solicita√ß√£o',
          value: codigoSolicitacao,
          inline: true,
        },
        {
          name: 'Status',
          value: '‚è≥ Aguardando Aprova√ß√£o do Gestor',
          inline: true,
        },
      ],
      timestamp: new Date().toISOString(),
      footer: {
        text: 'SGB - Sistema de Gest√£o de Bares',
      },
    };

    const payload = {
      embeds: [embed],
    };

    console.log('üì§ Enviando notifica√ß√£o para Discord...');
    console.log('üîó Webhook URL:', webhookUrl);
    console.log('üì¶ Payload:', JSON.stringify(payload, null, 2));

    // Enviar diretamente para o webhook do Discord
    const response = await fetch(webhookUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(payload),
    });

    console.log('üì° Status da resposta Discord:', response.status);
    console.log(
      'üì° Headers da resposta Discord:',
      Object.fromEntries(response.headers.entries())
    );

    if (!response.ok) {
      const errorText = await response.text();
      console.error('‚ùå Erro no Discord:', errorText);
      throw new Error(
        `Discord webhook error: ${response.status} - ${errorText}`
      );
    }

    console.log('‚úÖ Notifica√ß√£o enviada para Discord via webhook');
    return true;
  } catch (error) {
    console.error('‚ùå Erro ao enviar notifica√ß√£o Discord:', error);
    throw error;
  }
}

// Fun√ß√£o para identificar tipo de chave PIX (melhorada como no Python)
function identificarTipoChave(
  chave: string
): { tipo: string; chave: string } | null {
  if (!chave) return null;

  const chaveOriginal = chave;
  const chaveLimpa = chave.trim();

  console.log(`üîç Analisando chave: '${chaveOriginal}' -> '${chaveLimpa}'`);

  // Email (mais espec√≠fico)
  const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
  if (emailRegex.test(chaveLimpa)) {
    console.log(`‚úÖ Identificado como EMAIL: ${chaveLimpa}`);
    return { tipo: 'EMAIL', chave: chaveLimpa.toLowerCase() };
  }

  // Remover formata√ß√£o para an√°lise num√©rica
  const chaveNumerica = chaveLimpa.replace(/\D/g, '');

  // Verificar se √© telefone internacional
  let telefoneInternacional = false;
  if (chaveNumerica.startsWith('55') && chaveNumerica.length >= 12) {
    telefoneInternacional = true;
  }

  console.log(
    `üßπ Chave limpa: '${chaveNumerica}' (tamanho: ${chaveNumerica.length})`
  );

  // CNPJ (14 d√≠gitos)
  if (chaveNumerica.length === 14) {
    if (validarCNPJ(chaveNumerica)) {
      console.log(`‚úÖ Identificado como CNPJ v√°lido: ${chaveNumerica}`);
      return { tipo: 'CNPJ', chave: chaveNumerica };
    } else {
      console.log(
        `‚ö†Ô∏è CNPJ inv√°lido detectado: ${chaveOriginal} -> ${chaveNumerica}`
      );
      return { tipo: 'CNPJ', chave: chaveNumerica }; // Retorna mesmo se inv√°lido
    }
  }

  // CPF (11 d√≠gitos)
  if (chaveNumerica.length === 11) {
    if (validarCPF(chaveNumerica)) {
      console.log(`‚úÖ Identificado como CPF v√°lido: ${chaveNumerica}`);
      return { tipo: 'CPF', chave: chaveNumerica };
    } else {
      console.log(
        `‚ö†Ô∏è CPF inv√°lido detectado: ${chaveOriginal} -> ${chaveNumerica}`
      );
      return { tipo: 'CPF', chave: chaveNumerica }; // Retorna mesmo se inv√°lido
    }
  }

  // Telefone (10 ou 11 d√≠gitos)
  if (
    chaveNumerica.length === 10 ||
    chaveNumerica.length === 11 ||
    telefoneInternacional
  ) {
    let telefone = chaveNumerica;

    // Remover c√≥digo do pa√≠s se presente
    if (telefone.startsWith('55') && telefone.length >= 12) {
      telefone = telefone.slice(2);
    }

    // Validar formato brasileiro
    if (telefone.length === 11) {
      const ddd = telefone.slice(0, 2);
      if (parseInt(ddd) >= 11 && parseInt(ddd) <= 99 && telefone[2] === '9') {
        console.log(
          `‚úÖ Identificado como TELEFONE CELULAR v√°lido: ${telefone}`
        );
        return { tipo: 'TELEFONE', chave: `+55${telefone}` };
      }
    } else if (telefone.length === 10) {
      const ddd = telefone.slice(0, 2);
      if (parseInt(ddd) >= 11 && parseInt(ddd) <= 99) {
        console.log(`‚úÖ Identificado como TELEFONE FIXO v√°lido: ${telefone}`);
        return { tipo: 'TELEFONE', chave: `+55${telefone}` };
      }
    }

    console.log(
      `‚ö†Ô∏è Telefone com formato suspeito: ${chaveOriginal} -> ${telefone}`
    );
    return { tipo: 'TELEFONE', chave: `+55${telefone}` }; // Retorna mesmo se formato suspeito
  }

  // Chave aleat√≥ria (UUID)
  if (chaveLimpa.length >= 32 || chaveLimpa.includes('-')) {
    console.log(`‚úÖ Identificado como CHAVE ALEAT√ìRIA: ${chaveLimpa}`);
    return { tipo: 'ALEATORIA', chave: chaveLimpa };
  }

  // Caso n√£o consiga identificar claramente
  console.log(
    `‚ö†Ô∏è Tipo de chave n√£o identificado: ${chaveOriginal} -> ${chaveNumerica}`
  );

  // Inferir baseado no tamanho
  if (chaveNumerica.length > 14) {
    console.log(`üìù Inferindo como CHAVE ALEAT√ìRIA por tamanho`);
    return { tipo: 'ALEATORIA', chave: chaveLimpa };
  } else if (chaveNumerica.length > 11) {
    console.log(`üìù Inferindo como CNPJ por tamanho`);
    return { tipo: 'CNPJ', chave: chaveNumerica };
  } else if (chaveNumerica.length > 10) {
    console.log(`üìù Inferindo como CPF por tamanho`);
    return { tipo: 'CPF', chave: chaveNumerica };
  } else {
    console.log(`üìù Inferindo como TELEFONE por tamanho`);
    return { tipo: 'TELEFONE', chave: `+55${chaveNumerica}` };
  }
}

// Fun√ß√£o para validar CPF
function validarCPF(cpf: string): boolean {
  if (cpf.length !== 11 || cpf === cpf[0].repeat(11)) {
    return false;
  }

  // Primeiro d√≠gito verificador
  let soma = 0;
  for (let i = 0; i < 9; i++) {
    soma += parseInt(cpf[i]) * (10 - i);
  }
  let resto = soma % 11;
  const digito1 = resto < 2 ? 0 : 11 - resto;

  if (parseInt(cpf[9]) !== digito1) {
    return false;
  }

  // Segundo d√≠gito verificador
  soma = 0;
  for (let i = 0; i < 10; i++) {
    soma += parseInt(cpf[i]) * (11 - i);
  }
  resto = soma % 11;
  const digito2 = resto < 2 ? 0 : 11 - resto;

  return parseInt(cpf[10]) === digito2;
}

// Fun√ß√£o para validar CNPJ
function validarCNPJ(cnpj: string): boolean {
  if (cnpj.length !== 14 || cnpj === cnpj[0].repeat(14)) {
    return false;
  }

  // Primeiro d√≠gito verificador
  const pesos1 = [5, 4, 3, 2, 9, 8, 7, 6, 5, 4, 3, 2];
  let soma = 0;
  for (let i = 0; i < 12; i++) {
    soma += parseInt(cnpj[i]) * pesos1[i];
  }
  let resto = soma % 11;
  const digito1 = resto < 2 ? 0 : 11 - resto;

  if (parseInt(cnpj[12]) !== digito1) {
    return false;
  }

  // Segundo d√≠gito verificador
  const pesos2 = [6, 5, 4, 3, 2, 9, 8, 7, 6, 5, 4, 3, 2];
  soma = 0;
  for (let i = 0; i < 13; i++) {
    soma += parseInt(cnpj[i]) * pesos2[i];
  }
  resto = soma % 11;
  const digito2 = resto < 2 ? 0 : 11 - resto;

  return parseInt(cnpj[13]) === digito2;
}
